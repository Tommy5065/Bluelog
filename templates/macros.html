{# 做切换导航栏时对应的导航模块能激活，通过判读当前请求的端口和标签链接的端口是否相同 该宏在基模版中已被Bootstrap4提供的render_nav_item宏替代，有相同作用 #}
{% macro nav_item(endpoint,text) -%}
  <li class="nav-item{% if  request.endpoint and request.endpoint== endpoint%} active {% endif %} " >
    <a class="nav-link" href="{{ url_for(endpoint, **kwargs) }}">{{ text }}</a>
  </li>
{%- endmacro  %}

{# 做一个分页导航栏切换上下页:1.按钮是个超链接，可以发起对应页面的url请求 2.发起的请求中自带当前页数值。这样就不需要在请求中输入要查询的页数 #}
{# url_for生成的请求url链接中要判断是否存在上一页和下一页，不存在跳转到哪里 #}
{# fragment 的值会直接拼接到URL末尾（如 #section-name），用于跳转到页面内的特定位置（锚点） #}
{# 该宏已被bootstrap4提供的render_pager或render_pagination替代 #}
{% macro page(pagination, fragment='') %}
<nav aria-label="Page navigation">
    <ul class="pagination">
        <li class="page-item {% if not pagination.has_prev %}disabled{% endif %} ">
            <a class="page-link" href="{{ url_for(request.endpoint, page=pagination.prev_num, **kwargs) + fragment if pagination.has_prev else '#' }}">
                <span aria-hidden="true">&larr;</span>
                Previous
            </a>
        </li>
        <li class="page-item {% if not pagination.has_next %}disabled{% endif %} ">
            <a class="page-link" href="{{ url_for(request.endpoint, page=pagination.next_num, **kwargs) + fragment if pagination.has_next else '#' }}">
                <span aria-hidden="true">&rarr;</span>
                Next
            </a>
        </li>
    </ul>
</nav>
{% endmacro %}
